// Generated by mdclaw /generate-tests

import { describe, it, expect } from 'vitest';
import { parseIpcContract } from '../contract-harness.js';
import { resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import fs from 'node:fs';
import os from 'node:os';
import path from 'node:path';

const __dirname = fileURLToPath(new URL('.', import.meta.url));
const IPC_PATH = resolve(__dirname, '../../.claude/skills/add-containers/ipc-protocol.md');

describe('IPC contract conformance', () => {
  const commands = parseIpcContract(IPC_PATH);

  it('should parse all expected command types', () => {
    const types = commands.map(c => c.type);
    expect(types).toContain('schedule_task');
    expect(types).toContain('pause_task');
    expect(types).toContain('resume_task');
    expect(types).toContain('cancel_task');
    expect(types).toContain('refresh_groups');
    expect(types).toContain('register_group');
  });

  for (const cmd of commands) {
    describe(`command ${cmd.type}`, () => {
      it('should have valid structure', () => {
        expect(cmd.type).toBeTruthy();
        expect(Array.isArray(cmd.payloadFields)).toBe(true);
      });

      it('should round-trip through JSON', () => {
        const payload: Record<string, unknown> = {};
        for (const field of cmd.payloadFields) {
          payload[field] = `test-${field}`;
        }

        const command = {
          type: cmd.type,
          payload,
          source_group: 'test-group',
        };

        const json = JSON.stringify(command);
        const parsed = JSON.parse(json);
        expect(parsed.type).toBe(cmd.type);
        expect(parsed.source_group).toBe('test-group');

        for (const field of cmd.payloadFields) {
          expect(parsed.payload[field]).toBe(`test-${field}`);
        }
      });
    });
  }

  describe('authorization rules', () => {
    it('refresh_groups should be main group only', () => {
      const cmd = commands.find(c => c.type === 'refresh_groups');
      expect(cmd).toBeDefined();
      expect(cmd!.mainGroupOnly).toBe(true);
    });

    it('register_group should be main group only', () => {
      const cmd = commands.find(c => c.type === 'register_group');
      expect(cmd).toBeDefined();
      expect(cmd!.mainGroupOnly).toBe(true);
    });

    it('schedule_task should not be main group only', () => {
      const cmd = commands.find(c => c.type === 'schedule_task');
      expect(cmd).toBeDefined();
      expect(cmd!.mainGroupOnly).toBe(false);
    });
  });

  describe('close sentinel', () => {
    it('should write _close file', () => {
      const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'ipc-test-'));
      const inputDir = path.join(tmpDir, 'test-group', 'input');
      fs.mkdirSync(inputDir, { recursive: true });

      const closePath = path.join(inputDir, '_close');
      fs.writeFileSync(closePath, '');

      expect(fs.existsSync(closePath)).toBe(true);
      expect(fs.readFileSync(closePath, 'utf8')).toBe('');

      // Cleanup
      fs.rmSync(tmpDir, { recursive: true });
    });
  });

  describe('command file naming', () => {
    it('should match timestamp-random.json pattern', () => {
      const filename = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}.json`;
      expect(filename).toMatch(/^\d+-[a-z0-9]+\.json$/);
    });
  });
});
