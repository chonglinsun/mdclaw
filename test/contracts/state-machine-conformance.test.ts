// Generated by mdclaw /generate-tests

import { describe, it, expect } from 'vitest';
import { parseStateMachineContract } from '../contract-harness.js';
import { readFileSync } from 'node:fs';
import { resolve } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = fileURLToPath(new URL('.', import.meta.url));
const SM_PATH = resolve(__dirname, '../../.claude/skills/add-orchestrator/state-machine.md');
const INDEX_PATH = resolve(__dirname, '../../src/index.ts');

describe('State machine contract conformance', () => {
  const sm = parseStateMachineContract(SM_PATH);
  const indexSrc = readFileSync(INDEX_PATH, 'utf8');

  it('should define all expected states', () => {
    expect(sm.states).toContain('INITIALIZING');
    expect(sm.states).toContain('RECOVERING');
    expect(sm.states).toContain('POLLING');
    expect(sm.states).toContain('PROCESSING');
    expect(sm.states).toContain('EXECUTING');
    expect(sm.states).toContain('SHUTTING_DOWN');
  });

  for (const state of sm.states) {
    it(`should reference state ${state} in src/index.ts`, () => {
      // States appear in index.ts as comments like "--- INITIALIZING ---", "--- POLLING ---"
      // or as semantic concepts (shutdown, pollLoop, etc.)
      const stateMapping: Record<string, string[]> = {
        INITIALIZING: ['initializing', 'init'],
        RECOVERING: ['recovering', 'unprocessed'],
        POLLING: ['polling', 'poll'],
        PROCESSING: ['processing', 'process', 'trigger'],
        EXECUTING: ['executing', 'execute', 'container', 'startContainer'],
        SHUTTING_DOWN: ['shutting', 'shutdown', 'shutting_down'],
      };

      const patterns = stateMapping[state] ?? [state.toLowerCase()];
      const indexLower = indexSrc.toLowerCase();
      const has = patterns.some(p => indexLower.includes(p));
      expect(has).toBe(true);
    });
  }

  describe('signal handlers', () => {
    it('should register SIGTERM handler', () => {
      expect(indexSrc).toContain('SIGTERM');
    });

    it('should register SIGINT handler', () => {
      expect(indexSrc).toContain('SIGINT');
    });
  });

  describe('shutdown sequence', () => {
    it('should write close sentinel during shutdown', () => {
      expect(indexSrc).toContain('writeCloseSentinel');
    });

    it('should disconnect channels during shutdown', () => {
      expect(indexSrc).toContain('disconnect');
    });

    it('should close database during shutdown', () => {
      expect(indexSrc).toContain('db.close');
    });

    it('should stop scheduler during shutdown', () => {
      expect(indexSrc).toContain('scheduler.stop');
    });

    it('should stop IPC watcher during shutdown', () => {
      expect(indexSrc).toContain('ipcWatcher.stop');
    });
  });

  describe('cursor rollback', () => {
    it('should reference lastProcessed cursor', () => {
      expect(indexSrc).toContain('lastProcessed');
    });

    it('should have setLastProcessed call', () => {
      expect(indexSrc).toContain('setLastProcessed');
    });
  });

  describe('concurrency', () => {
    it('should use group queue for concurrency control', () => {
      expect(indexSrc).toContain('createGroupQueue');
    });

    it('should track active containers', () => {
      expect(indexSrc).toContain('activeContainers');
    });
  });
});
