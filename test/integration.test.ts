// Generated by mdclaw /generate-tests
// Integration test: full pipeline with mocked container, using real imports

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import type Database from 'better-sqlite3';
import crypto from 'node:crypto';
import type { NewMessage, RegisteredGroup, ContainerInput } from '../src/types.js';
import { initDb, storeMessage, storeChatMetadata, getNewMessages, registerGroup, getRegisteredGroups } from '../src/db.js';
import { parseContainerOutput, parseAllOutputs } from '../src/container.js';

const OUTPUT_START_MARKER = '---NANOCLAW_OUTPUT_START---';
const OUTPUT_END_MARKER = '---NANOCLAW_OUTPUT_END---';

describe('Full pipeline integration', () => {
  let db: Database.Database;

  beforeEach(() => {
    db = initDb(':memory:');
  });

  afterEach(() => {
    db.close();
  });

  it('should process message through full pipeline', () => {
    // 1. Register a group
    const group: RegisteredGroup & { jid?: string } = {
      name: 'Test Group',
      folder: 'test-group',
      jid: 'test@g.us',
      trigger: '@Andy',
      added_at: new Date().toISOString(),
      requiresTrigger: false,
    };
    registerGroup(db, group as RegisteredGroup);

    // Verify registration
    const groups = getRegisteredGroups(db);
    expect(groups).toHaveLength(1);
    expect(groups[0].folder).toBe('test-group');

    // 2. Store a chat and message
    const chatJid = 'test@g.us';
    const timestamp = new Date().toISOString();
    storeChatMetadata(db, chatJid, timestamp, 'Test Chat');

    const message: NewMessage = {
      id: `msg-${crypto.randomUUID()}`,
      chat_jid: chatJid,
      sender: 'user1@s.whatsapp.net',
      sender_name: 'Alice',
      content: 'Hello @Andy, what time is it?',
      timestamp,
      is_from_me: false,
      is_bot_message: false,
    };
    storeMessage(db, message);

    // 3. Query new messages (trigger detection)
    const lastProcessed = new Date(Date.now() - 60000).toISOString();
    const newMessages = getNewMessages(db, chatJid, lastProcessed);
    expect(newMessages).toHaveLength(1);
    expect(newMessages[0].content).toBe('Hello @Andy, what time is it?');

    // 4. Build ContainerInput
    const containerInput: ContainerInput = {
      prompt: `Group: ${group.name} (${group.folder})\nTriggered by: ${message.sender_name}\n\nLatest message from ${message.sender_name}:\n${message.content}`,
      sessionId: crypto.randomUUID(),
      groupFolder: group.folder,
      chatJid,
      isMain: false,
      isScheduledTask: false,
      assistantName: 'Andy',
      secrets: { ANTHROPIC_API_KEY: 'test-key' },
    };

    // Verify ContainerInput structure
    expect(containerInput.prompt).toContain('Hello @Andy');
    expect(containerInput.groupFolder).toBe('test-group');
    expect(containerInput.chatJid).toBe('test@g.us');
    expect(containerInput.isMain).toBe(false);
    expect(containerInput.isScheduledTask).toBe(false);
    expect(containerInput.assistantName).toBe('Andy');
    expect(containerInput.secrets.ANTHROPIC_API_KEY).toBe('test-key');

    // 5. Mock container response with sentinel markers
    const mockContainerOutput = [
      'Some debug output...',
      OUTPUT_START_MARKER,
      'The current time is 3:42 PM.',
      OUTPUT_END_MARKER,
      'More debug...',
    ].join('\n');

    // 6. Parse response
    const parsedOutput = parseContainerOutput(mockContainerOutput);
    expect(parsedOutput).toBe('The current time is 3:42 PM.');

    // 7. Store bot response
    const botMessage: NewMessage = {
      id: `bot-${Date.now()}`,
      chat_jid: chatJid,
      sender: 'bot',
      sender_name: 'Andy',
      content: parsedOutput,
      timestamp: new Date().toISOString(),
      is_from_me: true,
      is_bot_message: true,
    };
    storeMessage(db, botMessage);

    // 8. Verify bot message is excluded from new messages query
    const afterBot = getNewMessages(db, chatJid, lastProcessed);
    expect(afterBot).toHaveLength(1); // Only the original user message, not bot message
  });

  it('should handle multiple sentinel outputs (streaming)', () => {
    const mockOutput = [
      OUTPUT_START_MARKER,
      'First response part',
      OUTPUT_END_MARKER,
      'Some processing...',
      OUTPUT_START_MARKER,
      'Second response part',
      OUTPUT_END_MARKER,
    ].join('\n');

    const allOutputs = parseAllOutputs(mockOutput);
    expect(allOutputs).toHaveLength(2);
    expect(allOutputs[0]).toBe('First response part');
    expect(allOutputs[1]).toBe('Second response part');

    // parseContainerOutput returns last one
    const lastOutput = parseContainerOutput(mockOutput);
    expect(lastOutput).toBe('Second response part');
  });

  it('should handle empty container output', () => {
    const output = parseContainerOutput('no markers here');
    expect(output).toBe('');
  });

  it('should build ContainerInput for scheduled tasks', () => {
    const containerInput: ContainerInput = {
      prompt: 'Check weather and post update',
      sessionId: crypto.randomUUID(),
      groupFolder: 'weather-bot',
      chatJid: 'weather@g.us',
      isMain: false,
      isScheduledTask: true,
      assistantName: 'Andy',
      secrets: { ANTHROPIC_API_KEY: 'test-key' },
    };

    expect(containerInput.isScheduledTask).toBe(true);
    expect(containerInput.prompt).toBe('Check weather and post update');
  });

  it('should enforce main group privileges in ContainerInput', () => {
    const mainInput: ContainerInput = {
      prompt: 'Admin task',
      sessionId: crypto.randomUUID(),
      groupFolder: 'main',
      chatJid: 'main@g.us',
      isMain: true,
      isScheduledTask: false,
      assistantName: 'Andy',
      secrets: { ANTHROPIC_API_KEY: 'test-key' },
    };

    const nonMainInput: ContainerInput = {
      prompt: 'User task',
      sessionId: crypto.randomUUID(),
      groupFolder: 'user-group',
      chatJid: 'user@g.us',
      isMain: false,
      isScheduledTask: false,
      assistantName: 'Andy',
      secrets: { ANTHROPIC_API_KEY: 'test-key' },
    };

    expect(mainInput.isMain).toBe(true);
    expect(nonMainInput.isMain).toBe(false);
  });

  it('should store and retrieve groups with jid', () => {
    const group: RegisteredGroup & { jid?: string } = {
      name: 'JID Test',
      folder: 'jid-test',
      jid: 'specific@g.us',
      trigger: '@Bot',
      added_at: new Date().toISOString(),
    };
    registerGroup(db, group as RegisteredGroup);

    const groups = getRegisteredGroups(db);
    const found = groups.find(g => g.folder === 'jid-test');
    expect(found).toBeDefined();
  });

  it('should handle cursor rollback scenario', () => {
    const chatJid = 'rollback@g.us';
    const t1 = '2024-01-01T12:00:00.000Z';
    const t2 = '2024-01-01T12:01:00.000Z';

    storeChatMetadata(db, chatJid, t2);

    storeMessage(db, {
      id: 'msg1',
      chat_jid: chatJid,
      sender: 'user',
      sender_name: 'User',
      content: 'First message',
      timestamp: t1,
    });

    storeMessage(db, {
      id: 'msg2',
      chat_jid: chatJid,
      sender: 'user',
      sender_name: 'User',
      content: 'Second message',
      timestamp: t2,
    });

    // Simulate cursor at t1 (before second message)
    let cursor = t1;

    // Get messages after cursor
    let messages = getNewMessages(db, chatJid, cursor);
    expect(messages).toHaveLength(1);
    expect(messages[0].content).toBe('Second message');

    // Advance cursor optimistically
    cursor = t2;

    // Simulate container failure â€” would need to roll back
    // After rollback, cursor is back to t1
    cursor = t1;
    messages = getNewMessages(db, chatJid, cursor);
    expect(messages).toHaveLength(1); // Message is still available
  });
});
