// Generated by mdclaw /generate-tests

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import type Database from 'better-sqlite3';
import crypto from 'node:crypto';
import fs from 'node:fs';
import os from 'node:os';
import path from 'node:path';
import type { NewMessage, RegisteredGroup, ContainerInput } from '../../src/types.js';
import { initDb, storeMessage, storeChatMetadata, getNewMessages, registerGroup, getRegisteredGroups } from '../../src/db.js';
import { parseContainerOutput, parseAllOutputs } from '../../src/container.js';

describe('Boundary integration tests', () => {
  let db: Database.Database;

  beforeEach(() => {
    db = initDb(':memory:');
  });

  afterEach(() => {
    db.close();
  });

  describe('Host→Container boundary (ContainerInput JSON)', () => {
    it('should survive JSON round-trip', () => {
      const input: ContainerInput = {
        prompt: 'Test prompt with "quotes" and <tags>',
        sessionId: crypto.randomUUID(),
        groupFolder: 'test-group',
        chatJid: 'test@g.us',
        isMain: false,
        isScheduledTask: false,
        assistantName: 'Andy',
        secrets: { ANTHROPIC_API_KEY: 'sk-test-key' },
      };

      const json = JSON.stringify(input);
      const parsed = JSON.parse(json) as ContainerInput;

      expect(parsed.prompt).toBe(input.prompt);
      expect(parsed.sessionId).toBe(input.sessionId);
      expect(parsed.groupFolder).toBe(input.groupFolder);
      expect(parsed.chatJid).toBe(input.chatJid);
      expect(parsed.isMain).toBe(input.isMain);
      expect(parsed.isScheduledTask).toBe(input.isScheduledTask);
      expect(parsed.assistantName).toBe(input.assistantName);
      expect(parsed.secrets.ANTHROPIC_API_KEY).toBe(input.secrets.ANTHROPIC_API_KEY);
    });

    it('should preserve all required fields', () => {
      const input: ContainerInput = {
        prompt: 'test',
        sessionId: 'sess-1',
        groupFolder: 'main',
        chatJid: 'chat@g.us',
        isMain: true,
        isScheduledTask: true,
        assistantName: 'Andy',
        secrets: {},
      };

      const keys = Object.keys(input);
      expect(keys).toContain('prompt');
      expect(keys).toContain('sessionId');
      expect(keys).toContain('groupFolder');
      expect(keys).toContain('chatJid');
      expect(keys).toContain('isMain');
      expect(keys).toContain('isScheduledTask');
      expect(keys).toContain('assistantName');
      expect(keys).toContain('secrets');
    });
  });

  describe('Container→Host boundary (sentinel markers)', () => {
    const START = '---NANOCLAW_OUTPUT_START---';
    const END = '---NANOCLAW_OUTPUT_END---';

    it('should parse single sentinel output', () => {
      const raw = `Debug log\n${START}\nHello from container\n${END}\nMore debug`;
      const output = parseContainerOutput(raw);
      expect(output).toBe('Hello from container');
    });

    it('should parse multiple sentinel outputs', () => {
      const raw = `${START}\nFirst\n${END}\n${START}\nSecond\n${END}`;
      const outputs = parseAllOutputs(raw);
      expect(outputs).toHaveLength(2);
      expect(outputs[0]).toBe('First');
      expect(outputs[1]).toBe('Second');
    });

    it('should return empty for no markers', () => {
      expect(parseContainerOutput('no markers')).toBe('');
      expect(parseAllOutputs('no markers')).toEqual([]);
    });
  });

  describe('Host↔IPC boundary (command files)', () => {
    it('should write and read command files correctly', () => {
      const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'ipc-boundary-'));

      const command = {
        type: 'schedule_task',
        payload: {
          prompt: 'Check weather',
          schedule_type: 'cron',
          schedule_value: '0 8 * * *',
          context_mode: 'group',
        },
        source_group: 'test-group',
      };

      const filename = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}.json`;
      const filepath = path.join(tmpDir, filename);

      // Write atomically (temp + rename)
      const tmpFile = filepath + '.tmp';
      fs.writeFileSync(tmpFile, JSON.stringify(command));
      fs.renameSync(tmpFile, filepath);

      // Read back
      const content = fs.readFileSync(filepath, 'utf8');
      const parsed = JSON.parse(content);

      expect(parsed.type).toBe('schedule_task');
      expect(parsed.payload.prompt).toBe('Check weather');
      expect(parsed.source_group).toBe('test-group');

      fs.rmSync(tmpDir, { recursive: true });
    });

    it('should handle all IPC command types', () => {
      const commandTypes = [
        'schedule_task', 'pause_task', 'resume_task',
        'cancel_task', 'refresh_groups', 'register_group',
      ];

      for (const type of commandTypes) {
        const cmd = { type, payload: {}, source_group: 'test' };
        const json = JSON.stringify(cmd);
        const parsed = JSON.parse(json);
        expect(parsed.type).toBe(type);
      }
    });
  });

  describe('Host↔DB boundary (operations)', () => {
    it('should store and query messages', () => {
      const chatJid = 'test@g.us';
      storeChatMetadata(db, chatJid, new Date().toISOString(), 'Test Chat');

      const msg: NewMessage = {
        id: 'test-msg-1',
        chat_jid: chatJid,
        sender: 'user1',
        sender_name: 'Alice',
        content: 'Hello world',
        timestamp: new Date().toISOString(),
        is_from_me: false,
        is_bot_message: false,
      };

      storeMessage(db, msg);

      const messages = getNewMessages(db, chatJid, '2000-01-01T00:00:00.000Z');
      expect(messages).toHaveLength(1);
      expect(messages[0].content).toBe('Hello world');
    });

    it('should register and retrieve groups', () => {
      const group: RegisteredGroup = {
        name: 'Boundary Test',
        folder: 'boundary-test',
        trigger: '@Andy',
        added_at: new Date().toISOString(),
      };

      registerGroup(db, group);
      const groups = getRegisteredGroups(db);
      expect(groups.find(g => g.folder === 'boundary-test')).toBeDefined();
    });

    it('should handle concurrent inserts (idempotent)', () => {
      const chatJid = 'dup@g.us';
      storeChatMetadata(db, chatJid, new Date().toISOString());

      const msg: NewMessage = {
        id: 'dup-msg',
        chat_jid: chatJid,
        sender: 'user1',
        sender_name: 'Alice',
        content: 'Duplicate test',
        timestamp: new Date().toISOString(),
      };

      storeMessage(db, msg);
      storeMessage(db, msg); // Should not throw (INSERT OR IGNORE)

      const messages = getNewMessages(db, chatJid, '2000-01-01T00:00:00.000Z');
      expect(messages).toHaveLength(1);
    });
  });

  describe('Host↔Channel boundary (bot message filtering)', () => {
    it('should exclude bot messages from getNewMessages', () => {
      const chatJid = 'filter@g.us';
      storeChatMetadata(db, chatJid, new Date().toISOString());

      // User message
      storeMessage(db, {
        id: 'user-msg',
        chat_jid: chatJid,
        sender: 'user1',
        sender_name: 'Alice',
        content: 'Hello @Andy',
        timestamp: new Date().toISOString(),
        is_from_me: false,
        is_bot_message: false,
      });

      // Bot message
      storeMessage(db, {
        id: 'bot-msg',
        chat_jid: chatJid,
        sender: 'bot',
        sender_name: 'Andy',
        content: 'Hello! How can I help?',
        timestamp: new Date(Date.now() + 1000).toISOString(),
        is_from_me: true,
        is_bot_message: true,
      });

      const messages = getNewMessages(db, chatJid, '2000-01-01T00:00:00.000Z');
      expect(messages).toHaveLength(1);
      expect(messages[0].id).toBe('user-msg');
    });

    it('should include bot messages in getMessagesSince (for context)', () => {
      const chatJid = 'context@g.us';
      storeChatMetadata(db, chatJid, new Date().toISOString());

      storeMessage(db, {
        id: 'ctx-user',
        chat_jid: chatJid,
        sender: 'user1',
        sender_name: 'Alice',
        content: 'Hello',
        timestamp: new Date().toISOString(),
      });

      storeMessage(db, {
        id: 'ctx-bot',
        chat_jid: chatJid,
        sender: 'bot',
        sender_name: 'Andy',
        content: 'Hi there',
        timestamp: new Date(Date.now() + 1000).toISOString(),
        is_bot_message: true,
      });

      // getMessagesSince includes all messages (for context building)
      const allMessages = db.prepare(
        'SELECT * FROM messages WHERE chat_jid = ? AND timestamp > ? ORDER BY timestamp ASC'
      ).all(chatJid, '2000-01-01T00:00:00.000Z') as NewMessage[];
      expect(allMessages).toHaveLength(2);
    });
  });
});
