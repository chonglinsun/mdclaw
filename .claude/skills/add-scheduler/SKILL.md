---
disable-model-invocation: true
---

# /add-scheduler — Task Scheduler and Group Queue

> **Note:** This skill is called automatically by `/setup`. You only need to run it individually if you want to generate the scheduler modules separately for customization.

Generates the scheduled task runner and per-group concurrency queue.

## Prerequisites

These files must exist (generated by `/add-core`):

- `src/types.ts` — must export `ScheduledTask`, `TaskRunLog`, `QueuedTask`, `GroupState`
- `src/config.ts` — must export `config` with `SCHEDULER_POLL_INTERVAL`, `MAX_CONCURRENT_CONTAINERS`
- `src/db.ts` — must export database functions
- `src/logger.ts` — must export `logger`

## Context

This is Layer 2b — task scheduling and concurrency control. The scheduler manages recurring tasks (cron expressions, intervals, one-time). The group queue ensures only one container runs per group at a time, with a global concurrency limit.

## Files to create

| File | Purpose |
|------|---------|
| `src/scheduler.ts` | Cron/interval/once task scheduling and execution |
| `src/group-queue.ts` | Per-group FIFO queue with global concurrency limit |
| `src/scheduler.test.ts` | Unit tests for scheduler logic |

## Behavioral requirements

### src/scheduler.ts

1. Export `createScheduler(db, executeTask)` where `executeTask` is an async callback:
   ```typescript
   type ExecuteTask = (task: ScheduledTask) => Promise<string>;
   ```
2. The scheduler must:
   - Poll the database every `SCHEDULER_POLL_INTERVAL` (60000ms) for due tasks
   - A task is "due" when `status === 'active'` and `next_run <= now`
   - For each due task, call `executeTask(task)` and handle the result
   - After execution:
     - Log the run in `task_run_logs` with duration and status
     - For `cron` tasks: compute and set `next_run` using `cron-parser`
     - For `interval` tasks: set `next_run` to `now + schedule_value` (ms)
     - For `once` tasks: set `status = 'completed'`
     - Update `last_run` and `last_result`
   - If `executeTask` throws: log error in `task_run_logs`, do NOT change task status (retry on next poll)
3. Export task management functions:
   - `createTask(db, task: Omit<ScheduledTask, 'id' | 'created_at' | 'last_run' | 'last_result'>)` — generate UUID, compute initial `next_run`, insert into DB
   - `pauseTask(db, taskId)` — set status to `'paused'`
   - `resumeTask(db, taskId)` — set status to `'active'`, recompute `next_run`
   - `cancelTask(db, taskId)` — set status to `'completed'`
   - `getTasksForGroup(db, groupFolder)` — return all tasks for a group
   - `getDueTasks(db)` — return tasks where `status = 'active'` and `next_run <= now`
4. Return `{ start(), stop() }` control object for the polling loop
5. Use `crypto.randomUUID()` for task IDs

### src/group-queue.ts

1. Export `createGroupQueue(maxConcurrent?: number)` that returns a queue manager:
   ```typescript
   interface GroupQueue {
     enqueue(groupJid: string, fn: () => Promise<void>): Promise<void>;
     isProcessing(groupJid: string): boolean;
     getPendingCount(groupJid: string): number;
     getGlobalActiveCount(): number;
     clear(groupJid: string): void;
   }
   ```
2. Per-group FIFO ordering: tasks for the same group run sequentially
3. Global concurrency limit: at most `maxConcurrent` (default: `MAX_CONCURRENT_CONTAINERS` = 5) tasks running across all groups
4. When a task completes (success or failure), automatically dequeue and run the next pending task for that group (if any), respecting the global limit
5. Retry logic with exponential backoff:
   - On failure, retry up to 5 times
   - Backoff: `Math.min(1000 * 2^attempt, 30000)` ms
   - After max retries, log error and discard the task
6. The `enqueue` function returns a promise that resolves when the task actually completes (not when it's enqueued)

### src/scheduler.test.ts

1. Test task creation: verify UUID generation, initial next_run computation
2. Test cron next_run calculation: given a cron expression and a "now" time, verify correct next_run
3. Test interval next_run calculation: verify next_run is now + interval
4. Test once task completion: after execution, status should be 'completed'
5. Test group queue ordering: enqueue 3 tasks for same group, verify they run in order
6. Test global concurrency: enqueue tasks across groups, verify max concurrent limit is respected

## Integration points

| Export | Used by |
|--------|---------|
| `createScheduler` | orchestrator (to start the scheduler loop) |
| `createTask`, `pauseTask`, etc. | ipc handler (to manage tasks from container commands) |
| `createGroupQueue` | orchestrator (to manage container execution concurrency) |

## Verification

```bash
# Type check
npx tsc --noEmit

# Unit tests
npx vitest run src/scheduler.test.ts
```
