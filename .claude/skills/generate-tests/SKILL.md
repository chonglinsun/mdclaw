---
disable-model-invocation: true
---

# /generate-tests — Contract-Derived Test Generation

Reads the 4 anchor contracts and generated source code, then produces test files that verify conformance at every integration boundary.

## Prerequisites

- All source files in `src/` generated (at minimum: `src/types.ts`, `src/db.ts`, `src/ipc.ts`, `src/index.ts`)
- `npm install` completed
- `test/contract-harness.ts` exists (shipped in repo — the parser library)

## Context

This skill replaces hand-written boundary tests with contract-derived tests. The test harness (`test/contract-harness.ts`) parses the 4 anchor contracts into structured data; this skill generates test files that use that structured data to verify the generated code.

**Anchor contracts:**

| Contract | Path | What it defines |
|----------|------|-----------------|
| Types | `.claude/skills/add-core/types-contract.ts` | All TypeScript interfaces |
| Schema | `.claude/skills/add-core/schema.sql` | All SQLite tables, constraints, indices |
| IPC | `.claude/skills/add-containers/ipc-protocol.md` | Command types, auth model, directory layout |
| State machine | `.claude/skills/add-orchestrator/state-machine.md` | Orchestrator states and transitions |

## Steps to perform

### Step 1: Read the contract harness

Read `test/contract-harness.ts` to understand the available parser functions and their return types:

- `parseTypesContract(path)` → `ParsedInterface[]`
- `parseSchemaContract(path)` → `ParsedTable[]`
- `parseIpcContract(path)` → `ParsedIpcCommand[]`
- `parseStateMachineContract(path)` → `ParsedStateMachine`

### Step 2: Read all contracts and generated source

Read these files to understand what the tests need to verify:

- `.claude/skills/add-core/types-contract.ts`
- `.claude/skills/add-core/schema.sql`
- `.claude/skills/add-containers/ipc-protocol.md`
- `.claude/skills/add-orchestrator/state-machine.md`
- `src/types.ts`
- `src/db.ts`
- `src/ipc.ts`
- `src/index.ts`
- `src/container.ts`
- `src/message-processor.ts`
- `container/agent-runner/src/index.ts`

### Step 3: Create test directories

```bash
mkdir -p test/contracts test/boundary
```

### Step 4: Generate test files

Generate 5 test files plus rewrite `test/integration.test.ts`. Each generated file should include the header: `// Generated by mdclaw /generate-tests`

#### 4a. `test/contracts/types-conformance.test.ts`

**Derives from:** `types-contract.ts`
**Verifies:** Every interface in the contract exists in `src/types.ts` with matching fields.

Strategy:
1. Use `parseTypesContract()` to get all contract interfaces
2. Read `src/types.ts` source text
3. For each contract interface, verify:
   - The interface name exists as an export in `src/types.ts`
   - Each field from the contract exists with the correct name and optionality
4. **Special case — ContainerInput cross-boundary match:** Verify that the `ContainerInput` interface fields match between the host (`src/types.ts`) and the container (`container/agent-runner/src/index.ts`). Read the agent-runner source and verify it expects the same fields that the host sends. This is the #1 failure boundary — if these diverge, the container silently fails to parse its input.

Test structure:
```typescript
import { describe, it, expect } from 'vitest';
import { parseTypesContract } from '../contract-harness.js';
import { readFileSync } from 'node:fs';
import { resolve } from 'node:path';

const CONTRACT_PATH = resolve(__dirname, '../../.claude/skills/add-core/types-contract.ts');
const TYPES_PATH = resolve(__dirname, '../../src/types.ts');
const AGENT_RUNNER_PATH = resolve(__dirname, '../../container/agent-runner/src/index.ts');

describe('Types contract conformance', () => {
  const interfaces = parseTypesContract(CONTRACT_PATH);
  const typesSrc = readFileSync(TYPES_PATH, 'utf8');

  for (const iface of interfaces) {
    describe(`interface ${iface.name}`, () => {
      it('should exist in src/types.ts', () => { ... });
      for (const field of iface.fields) {
        it(`should have field ${field.name}`, () => { ... });
      }
    });
  }

  describe('ContainerInput cross-boundary', () => {
    it('should match between host and agent-runner', () => { ... });
  });
});
```

#### 4b. `test/contracts/schema-conformance.test.ts`

**Derives from:** `schema.sql`
**Verifies:** Every table exists with correct columns, CHECK constraints are enforced, WAL mode is set.

Strategy:
1. Use `parseSchemaContract()` to get all contract tables
2. Import `initDb` from `src/db.ts` (or the exported init function) and create an in-memory database
3. For each table:
   - Use `PRAGMA table_info(tableName)` to verify columns exist with correct types and nullability
   - For tables with CHECK constraints, attempt invalid inserts and verify they throw
4. Verify WAL mode: `PRAGMA journal_mode` should return `wal`
5. For each expected index, verify with `PRAGMA index_list(tableName)`

Test structure:
```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { parseSchemaContract } from '../contract-harness.js';
import { resolve } from 'node:path';

const SCHEMA_PATH = resolve(__dirname, '../../.claude/skills/add-core/schema.sql');

describe('Schema contract conformance', () => {
  const tables = parseSchemaContract(SCHEMA_PATH);
  // Import initDb from src/db.ts and create :memory: db
  // Use PRAGMA table_info to verify each table
  // Test CHECK constraints with invalid inserts
  // Test WAL mode
});
```

**Important:** Import `initDb` (or whatever the db initialization function is named) from `../../src/db.js` and call it with `':memory:'` to get a real database with the schema applied. Read `src/db.ts` to find the exact export name.

#### 4c. `test/contracts/ipc-conformance.test.ts`

**Derives from:** `ipc-protocol.md`
**Verifies:** Command round-trip, source_group validation, main group authorization, close sentinel.

Strategy:
1. Use `parseIpcContract()` to get all command types
2. For each command type:
   - Construct a valid command JSON with correct `type`, `payload`, and `source_group`
   - Write to a temp file, read back, verify structure
3. Test authorization rules:
   - `source_group` mismatch → verify it would be rejected (check against the contract's rule)
   - `refresh_groups` from non-main group → verify main-group-only flag
   - `register_group` from non-main group → verify main-group-only flag
4. Test close sentinel: write empty `_close` file, verify it exists
5. Test command file naming: verify `${timestamp}-${random}.json` pattern

If `src/ipc.ts` exports validation or processing functions, import and test them directly. Otherwise, test the contract structurally (JSON round-trip, field presence).

#### 4d. `test/contracts/state-machine-conformance.test.ts`

**Derives from:** `state-machine.md`
**Verifies:** All states referenced in `src/index.ts`, shutdown sequence, cursor rollback, signal handlers.

Strategy:
1. Use `parseStateMachineContract()` to get states and transitions
2. Read `src/index.ts` source text
3. For each state in the contract:
   - Verify the state name appears in `src/index.ts` (as a string literal, enum value, or comment)
4. Verify structural properties from the state machine spec:
   - Signal handlers registered (SIGTERM, SIGINT referenced in source)
   - Shutdown sequence: verify `_close` sentinel writing, channel disconnect, db close are all present
   - Cursor rollback: verify `lastProcessed` rollback logic exists
   - Concurrency: verify `MAX_CONCURRENT_CONTAINERS` or equivalent limit referenced

#### 4e. `test/boundary/integration.test.ts`

**Derives from:** All contracts + `src/`
**Verifies:** The 5 real failure boundaries with real imports from `src/`.

This replaces any inline test logic that duplicated contract data. The test should:

1. **Host→Container boundary:** Import `ContainerInput` from `src/types.ts`, construct one, serialize to JSON, verify all fields survive `JSON.parse()` round-trip
2. **Container→Host boundary:** Test sentinel marker parsing — construct output with `---NANOCLAW_OUTPUT_START---` and `---NANOCLAW_OUTPUT_END---`, parse it, verify extracted content matches. Import the parsing function from `src/container.ts` if exported, otherwise inline the parser.
3. **Host↔IPC boundary:** Write a command JSON to a temp directory, verify it round-trips correctly. Test each command type from the IPC contract.
4. **Host↔DB boundary:** Import `initDb` from `src/db.ts`, create in-memory DB, insert and query from each table. Use real types from `src/types.ts`.
5. **Host↔Channel boundary (bot message filtering):** Insert messages with `is_bot_message=true`, verify they're excluded from `getNewMessages` queries (the query uses `AND is_bot_message = 0`).

### Step 5: Rewrite `test/integration.test.ts`

Rewrite the existing integration test to use real imports instead of inline copies:

**Remove:**
- Inline interface definitions (`NewMessage`, `RegisteredGroup`, `ContainerInput` — ~30 lines)
- Inline `SCHEMA` constant (~65 lines)
- Inline `initTestDb()` function

**Replace with:**
- `import type { NewMessage, RegisteredGroup, ContainerInput } from '../src/types.js';`
- Import `initDb` from `../src/db.js` and use `initDb(':memory:')` instead of inline schema
- If `initDb` doesn't accept a path argument, read `src/db.ts` to determine how to create an in-memory test database

**Keep:**
- All 7 test cases and their logic
- Helper functions (`storeChat`, `storeMessage`, `getNewMessages`, `registerGroup`, `getRegisteredGroups`) — but verify they match the schema contract
- `parseContainerOutput` and `parseAllOutputs` helper functions
- Sentinel marker constants

The goal is to eliminate the inline copies that can drift from the contracts, while keeping the pipeline simulation tests that verify real behavior.

### Step 6: Verify

Run all tests to confirm everything passes:

```bash
npx vitest run test/contracts/
npx vitest run test/boundary/
npx vitest run test/integration.test.ts
npx vitest run
```

All must pass. If any fail, fix the generated test code and re-run.

## Output format

Report which test files were generated and their results:

```
/generate-tests complete
========================

Generated files:
  test/contracts/types-conformance.test.ts
  test/contracts/schema-conformance.test.ts
  test/contracts/ipc-conformance.test.ts
  test/contracts/state-machine-conformance.test.ts
  test/boundary/integration.test.ts

Rewritten:
  test/integration.test.ts (removed inline types/schema, uses real imports)

Test results:
  npx vitest run → all suites pass
```

## Verification

```bash
npx tsc --noEmit         # Zero type errors (including new test files)
npx vitest run            # All tests pass
```
